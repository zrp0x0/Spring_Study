# Ch05. API를 작성하는 다양한 방법

## GET API 만들기
- 실무에서는 HTTP 메서드에 따라 컨트롤러 클래스를 구분하지 않음

### @RequestMapping으로 구현하기
- 클래스 수준에서 @RequestMapping을 설정하면 내부에 선언한 메서드의 URL 리소스 앞에 @RequestMapping의 값이 공통 값으로 추가됨
- @RequestMapping은 별다른 설정 없이 선언하면 HTTP의 모든 요청을 받음
- 특정 형식의 요청만 받기 위해서는 별도의 설정이 필요함
```java
@RequestMapping(value = "/hello", method = RequestMethod.GET)
```
- 스프링 4.3 버전 이후로는 새로 나온 어노테이션을 사용함
    - @GetMapping
    - @PostMapping
    - @PutMapping
    - DeleteMapping

### 매개변수가 없는 GET 메서드 구현
- 별도의 매개변수 없이 GET API를 구현하는 경우
```java
@GetMapping(value = "/name")
```

### @PathVariable을 활용한 GET 메서드 구현
- 실무 환경에서는 매개변수를 받지 않는 메서드가 거의 쓰이지 않음
- 웹 통신의 기본 목적은 데이터를 주고받는 것이기 때문에 매개변수를 받는 매서드를 작성하게 됨
- 자주 쓰이는 방법 중 하나가 URL 자체에 값을 담아 요청하는 것
```java
    // http://localhost:8080/api/v1/get-api/variable1/{String 값}
    @GetMapping(value = "/variable1/{variable}")
    public String getVaribale(@PathVariable String variable) {
        return variable;
    }
```
    - 요청 URL을 보면, {}로 표시된 위치의 값을 받아 요청하는 것을 알 수 있음
    - **실제 요청 시 중괄호는 사용하지 않음**
    - GET 요청에서 많이 사용됨

- 몇 가지 지켜야 할 규칙
    - @GetMapping의 값으로 URL을 입력할 때 중괄호를 사용해 어느 위치에서 값을 받을지 지정해야함
    - 또한 메서드이 매개변수와 그 값을 연결하기 위해서 @PathVariable을 명시하며
    - @GetMapping과 @PathVariable에 지정된 변수의 이름을 동일하게 
        - 만약 맞추기 어렵다면?
        ```java
        // http://localhost:8080/api/v1/get-api/variable2/{String 값}
        @GetMapping(value = "/variable2/{variable}")
        public String getVaribale2(@PathVariable(value = "variable") String var) {
            return var;
        }
        ```

### @ReqeustParam을 활용한 GET 메서드 구현
- GET 요청을 구현할 때, 앞에서 살펴본 방법처럼 URL 경로에 값을 담아 요청을 보내는 방법 외에도 쿼리 형식으로 값을 전달할 수도 있음
- URL에서 ?를 기준으로 우측에 "{key}={value}" 형태로 구성됨
- 애플리케이션이서 이 같은 형식을 처리하려면 @RequestParam을 활용
```java
// http://localhost:8080/api/v1/get-api/request1?name=value1&email=value2&organization=value3
    @GetMapping(value = "/request1")
    public String getRequestParam1(
        @RequestParam("name") String name,
        @RequestParam String email,
        @RequestParam String organization
    ) {
        return name + " " + email + " " + organization;
    }
```
    - ?오른쪽에 **쿼리 스트링**이 명시되어 있음
    - 키의 이름과 메서드의 매개변수 이름을 매핑하면됨
    - 만약 동일하게 설정하기 어려울 경우 @PathVariable처럼 value로 매핑하면 됨

- 만약 쿼리 스트링에 무슨 값이 들어올지 모른다면?
    - Map 객체를 활용
    ```java
    // http://localhost:8080/api/v1/get-api/request2?name=value1&email=value2&organization=value3
    @GetMapping(value = "/request2")
    public String getRequestParam2(
        @RequestParam Map<String, String> param
    ) {
        StringBuilder sb = new StringBuilder();
        param.forEach((key, value) -> sb.append(key + " : " + value + "\n"));

        return sb.toString();
    }
    ```
    - 회원 가입 관련 API에서 사용자는 회원 가입을 하면서 ID같은 필수 항목이 아닌 취미 같은 선택 항목에 대해서는 값을 기입하지 않는 경우가 있음
    - 이와 같이 **매개변수의 항목이 일정하지 않을 수 있는 경우** Map 객체로 받는 것이 효율적임

### URI vs URL
- URL은 흔히 말하는 웹 주소를 의미하며, 리소스가 어디에 있는지 알려주는 경로
- URI는 특정 리소를 식별할 수 있는 식별자를 의미함
- URI은 URL을 포함하는 개념
    - URI: google.com
    - URL: https://google.com (이름과 더불어 어떻게 도달할 수 있는지 알 수 있음)

### DTO 객체를 활용한 GET 메서드 구현
- DTO란?
    - Data Transfer Object
    - 다른 레이어 간의 데이터 교환에 활용됨
    - 각 클래스 및 인터페이스를 호출하면서 전달하는 매개변수로 사용되는 데이터 객체
    - DTO는 데이터를 교환하는 용도로만 사용되는 객체이기 때문에 DTO에는 별도의 로직이 포함되지 않음
    
### DTO vs VO
- DTO와 VO(Value Object)의 역할을 엄밀하게 구분하지 않고 사용할 때가 많음
- 대부분의 상황에서는 문제가 발생하지 않음
- 엄밀한 차이
    - VO는 데이터 그 자체로 의미가 있는 객체를 의미함
    - **Read-Only**로 설계한다는 점
    - 값을 변경할 수 없게 만들어 데이터의 신뢰성을 유지해야함

    - DTO는 다른 레이어간 데이터 교환에 활용됨
    - 레이어란 애플리케이션 내부에 정의된 레이어일 수도 있고, 인프라 관점에서 서버 아키텍처 상의 레이어일 수도 있음

```java
// http://localhost:8080/api/v1/get-api/request3?name=value1&email=value2&organization=value3
@GetMapping(value = "/request3")
public String getRequestParam3(@ModelAttribute MemberDto memberDto) {
    return memberDto.toString();
}
```
- 기본적으로 @ModelAttribute가 생략된 형태임
- 해당 객체의 필드명과 쿼리 스트링의 key값을 기준으로 매핑
- **반드시 Setter가 있어야함**
- 만약 필드명과 쿼리 스트링의 key값을 동일하게 하지 못할 경우
    - (@RequestParam(value = "key") 원하는 이름)으로 쪼개서 받는 것이 좋음

--

## POST API 만들기
- POST API는 웹 애플리케이션을 통해 데이터베이스 등의 저장소에 리소스를 저장할 때 사용
- GET API에서는 URL의 경로나 파라미터에 변수를 넣어 요청을 보냈지만,
- POST API에서는 저장하고자하는 리소스나 값을 HTTP Body에 담아 서버에 전달함

### @RequestMapping으로 구현하기
```java
@RequestMapping(value = "domain", method = RequestMethod.POST)
public String postExample() {
    return "Hello Post API";
}
```

### @RequestBody를 활용한 POST 메서드 구현
- 일반적으로 POST 형식의 요청은 클라이언트가 서버에 리소스를 저장하는데 사용함
- 따라서 클라이언트의 요청 트래픽에 값이 포함되어 있음
- POST 요청에서는 HTTP Body에 값을 넣어 전송함
    - Body에 작성되는 값은 일정한 형태를 취함 -> JSON(JavaScript Object Notation)
```java
@RequestMapping(value = "domain", method = RequestMethod.POST)
public String postExample() {
    return "Hello Post API";
}

@PostMapping(value = "/member")
public String postMember(@RequestBody Map<String, Object> postData) {
    StringBuilder sb = new StringBuilder();
    postData.forEach((key, value) -> { sb.append(key + " : " + value + '\n'); });

    return sb.toString();
}
```

### @ModelAttribute vs @RequestBody
- @ModelAttribute
    - Query-String 또는 Form-data
    - Key-Value
    - Property Binding (Setter / 생성자)
    - 검색 필터링 / 일반적인 폼 전송
    - **부분적인 바인딩이 가능 나머지는 null로 채움**
    - **생략 가능**

- @RequestBody
    - HTTP Body
    - JSON / XML {"name" : "kim"}
    - Message Conversion (Jackson 라이브러리) / (기본 생성자와 Getter/필드)가 필요함
    - REST API, AJAX 통신
    - JSON 형식이 깨져있거나, 타입이 맞지 않으면 바인딩 자체가 실패하고 HttpMessageNotReadableException이 발생함
    - **생략 불가능**

### DTO로 받기
- @RequestBody로 반드시 받아야함
- 알아서 키와 값으로 매핑함
    - 만약 못 맞출 시
    ```java
    public class MemberDto {
        @JsonProperty("user_name") // JSON의 user_name을 name 필드에 매핑
        private String name;
        private String email;
        private String organization;
    }
    ```

```java
@PostMapping(value = "/member2")
public String postMemberDto(@RequestBody MemberDto memberDto) {
    return memberDto.toString();
}
```

---

## PUT API 만들기
- PUT API는 서버를 통해 데이터베이스 같은 저장소에 **존재하는** 리소스 값을 업데이트 하는데 사용함
- POST API와 비교하면 실제 데이터베이스에 반영하는 과정(서비스 로직)에서 차이가 있지만
- 컨트롤러 클래스를 구현하는 방법은 POST API와 거의 동일함
- 리소스를 서버에 전달하기 위해서 HTTP Body를 활용해야함

### @RequestBody를 활용한 PUT 메서드 구현
```java
@PutMapping(value = "/member") 
public String postMember(@RequestBody Map<String, Object> putData) {
    StringBuilder sb = new StringBuilder();
    putData.forEach((key, value) -> sb.append(key + " : " + value + "\n"));
    return sb.toString();
}
```
- 서버에 들어오는 요청으로 어떤 값이 들어오는지 모를 경우 이렇게 받을 수 있음

### DTO 객체를 활용한 PUT 메서드 구현
```java
@PutMapping(value = "/member1")
public String postMemberDto1(@RequestBody MemberDto memberDto) {
    return memberDto.toString();
}

@PutMapping(value = "/member2")
public MemberDto postMemberDto2(@RequestBody MemberDto memberDto) {
    return memberDto;
}
```
- 1번은 String 타입으로 반환
- 2번은 DTO 객체 타입으로 반환

### Return String? DTO? 둘은 어떤 차이가 있을까?
- 클라이너트가 받은 응답의 Content-Type을 보면 
    - String은 text/plain
    - DTO는 application/json

- HTTPMessageConverter 우선순위
    - ByteArrayHttpMessageConverter | byte[] |application/octet-stream
    - StringHttpMessageConverter | String |text/plain
    - ResourceHttpMessageConverter |Resource | (파일 종류에 따름)
    - MappingJackson2HttpMessageConverter |Object (DTO 등) | application/json

- 또한 핵심은 @RestController = @Controller + @ResponseBody
    - @ResponoseBody가 없으면 View Resolver가 동작해서 해당 문자열로 이루어진 view를 찾으려고함
    - 당연히 DTO를 반환하면 404에러 발생

### ResponseEntity를 활용한 PUT 메서드 구현
- Spring에는 HttpEntity라는 클래스가 있음
```java
public class HttpEntity<T> {
    private final HttpHeaders headers;

    @Nullable
    private final T body;
    
    ...
}
```
- header와 body로 구성되어있음
- ResponseEntity는 HttpEntity를 상속받아 구현한 클래스임
- 자체적으로 HttpStatusCode를 가지고 있음
```java
@PutMapping(value = "/member3")
public ResponseEntity<MemberDto> postMemberDto3(@RequestBody MemberDto memberDto) {
    return ResponseEntity
        .status(HttpStatus.ACCEPTED)
        .body(memberDto);
}
```
    - 다른 GET / POST / DELETE 등 HTTP 메서드에서 사용할 수 있음
    - status를 통해서 응답 코드를 지정해서 반환할 수 있음

---

## DELETE API 만들기
- DELETE API는 애플리케이션 서버를 거쳐 데이터베이스 등의 저장소에 있는 리소스를 삭제할 때 사용함
- 이때 서버는 클라이언트로부터 리소스를 식별할 수 있는 값을 받아 데이터베이스나 캐시에 있는 리소스를 조회하고 삭제하는 역할을 수행
- 이때 컨트롤러를 통해 값을 받는 단계에서는 간단한 값을 받기 때문에 GET 메서드와 같이 URI에 값을 넣어 요청을 받는 형식으로 구현됨

### @PathVariable과 @RequestParam을 활용한 DELETE 메서드 구현
```java
// http://localhost:8080/resource-id
@DeleteMapping(value = "/{variable}")
public String DeleteVariable(@PathVariable String variable) {
    // 삭제하는 로직...
    return variable;
}
```

```java
// http://localhost:8080/request1?email=value1
@DeleteMapping(value = "/request1")
public String getRequestParam1(@RequestParam String email) {
    return "e-mail: " + email;
}
```

### REST API 명세를 문서화하는 방법 - Swagger
- API를 개발하면 명세를 관리해야함
- 명세란 해당 API가 어떤 로직을 수행하는지 설명하고 수행하기 위해서는 어떤 값을 요청하며, 이에 따른 응답값으로 무엇을 받을 수 있는지를 정리한 자료
- 과거에는 계속해서 변경되는 API 명세 작업이 힘들었지만 Swagger라는 오픈 소스 프로젝트로 인해서 편리해짐

- 의존성 설정
```java
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0'
```

- config/SwaggerConfiguration.java
```java
package com.zrp.api.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;

@Configuration
public class SwaggerConfiguration {
    
    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI().components(new Components()).info(apiInfo());
    }

    private Info apiInfo() {
        return new Info()
                .title("Spring Boot Open API Test with Swagger")
                .description("설명 부분")
                .version("1.0.0");
    }
}
```
- Swagger 라이브러리는 스프링 컨테이너에 OpenAPI 타입의 빈이 등록되어 있으면, 이를 기반으로 swagger-ui.html 화면을 

- .components(new Components()):
    - API 문서에서 공통으로 사용할 요소(Components)를 설정하는 부분
    - 주로 JWT 인증(Security Scheme) 등을 정의할 때 사용하며, 지금처럼 빈 객체를 넣으면 기본값으로 세팅

- info(apiInfo()): API의 제목, 설명, 버전 등 '메타 데이터'를 설정하기 위해 아래 작성한 apiInfo() 메서드를 호출

- 내부 동작
    - @RestController들을 뒤져서 어떤 API가 있는지 분석한 뒤, 우리가 설정한 Info 정보와 합칩
    - @Controller가 @ResponseBody를 가지고 있지 않으면 안 나올 수 있음
    
- 실제 접속
    - http://localhost:8080/swagger-ui/index.html

### Swagger 활용
```java
@Operation(summary = "GET 메서드 예제", description = "@RequestParam을 활용한 GET 메서드")
@GetMapping(value = "/request1")
public String getRequestParam1(
    @Parameter(name = "namefield", description = "이름", required = true) @RequestParam("name") String name,
    @RequestParam String email,
    @RequestParam String organization
) {
    return name + " " + email + " " + organization;
}
```
    - @Operation: 대상 API의 설명을 작성하기 위한 어노테이션
    - @Parameter: 매개변수에 대한 설명 및 설정을 위한 어노테이션, 메서드의 매개변수 뿐 아니라 DTO 객체를 매개변수로 사용할 경우 DTO 클래스 내의 매개변수도 정의할 수 있음
    - Try-It을 통해 직접 서버와 통신할 수도 있음 (실제로 결과 반영됨!!)

### 추가 활용
```java
import io.swagger.v3.oas.annotations.media.Schema;

public class MemberDto {

    @Schema(description = "사용자 이름", example = "홍길동", requiredMode = Schema.RequiredMode.REQUIRED)
    private String name;

    @Schema(description = "사용자 이메일", example = "test@example.com")
    private String email;

    @Schema(description = "소속 단체", example = "건국대학교")
    private String organization;
}
```
    - DTO 내부에서 사용할 때는 @Schema를 사용
    - example: 미리 작성되어있음
    - requiredMode: 만드시 필요한 사항

```java
@Operation(summary = "회원 가입 요청")
@Parameters({
    @Parameter(name = "name", description = "회원의 실명", example = "이순신", in = ParameterIn.QUERY),
    @Parameter(name = "email", description = "가입할 이메일 주소", example = "navy@korea.com", in = ParameterIn.QUERY)
})
@PostMapping("/join")
public String join(MemberDto memberDto) {
    return "success";
}
```
    - 위와 같이 @Paramter 안에 저런 형식으로 사용하여, 설명을 할 수 있음
    - ParameterIn.QUERY: 쿼리 스트링으로 들어오는 파라미터임을 암시
        - 추가 내용:
            - Form을 GET으로 보내면 쿼리스트링으로 날아오고
            - PUT으로 보내면 바디로 날아옴 (application/x-www-form-urlencoded(name=value)) not JSON
            - @ModelAttribute나 @RequestParam으로도 받을 수 있음
            - @ModelAttribute라고 반드시 Query String으로 받아야하는 것이 아님 (키=값)
            - 근데 주의해야하는 건 JSON, 즉 axios, fetch로 오는 건 @RequestBody로 받아야함

---

## 로깅 라이브러리 - Logback
- logging이란 애플리케이션이 동작하는 동안 시스템의 상태나 동작 정보를 시간순으로 기록하는 것을 의미함
- 사실상 **비기능 요구사항**에 속함
- 근데 디버깅이나 개발 이후 발생한 문제를 해결하기 위해서 꼭 필요함
- 자바 진영에서 가장 많이 사용되는 로깅 프레임워크는 Logback
    - log4j 이후에 출시된 slf4j를 기반으로 구현됨
    - spring-boot-starter-web 라이브러리 내부에 내장되어있어 별도의 의존성을 설치하지 않아도 됨

### Logback의 특징
- 크게 5가지 로그 레벨(TRACE / DEBUG / INFO / WARN / ERROR)
    - ERROR: 로직 수행 중에 시스템에 심각한 문제가 발생해서 애플리케이션의 작동이 불가능한 경우를 의미
    - WARN: 시스템 에러의 원인이 될 수 있는 경고 레벨을 의미함
    - INFO: 애플리케이션의 상태 변경과 같은 정보 전달을 위해 사용됨
    - DEBUG: 애플리케이션의 디버깅을 위한 메시지를 표기하는 레벨을 의미함
    - TRACE: DEBUG 레벨보다 더 상세한 메시지를 표현하기 위한 레벨을 의미함

- 실제 운영환경과 개발 환경에서 각각 다른 출력 레벨을 설정해서 로그를 확인할 수 있음
- Logback의 설정 파일을 이정 시간마다 스캔해서 애플리케이션을 재가동하지 않아도 설정을 변경할 수 있음
- 별도의 프로그램 지원 없이도 자체적으로 로그 파일을 압축할 수 있음
- 저장된 로그 파일에 대한 보관 기관 등을 설정해서 관리할 수 있음

### Logback 설정
- 일반적으로 classpath에 있는 설정 파일을 자동으로 참조하므로 Logback 설정 파일은 리소스 폴더 안에 생성함
- 일반적인 자바 또는 스프링 프로젝트는 logback.xml이라는 이름으로 참조
- 스프링 부트에서는 logback-spring.xml 파일을 참조함
    - resources/logback-spring.xml

### 설정 파일 영역 별
- Property
- Appender
- Encoder
- Pattern
- Root

#### Appender
- 로그의 형태를 설정하고 어떤 방법으로 출력할지를 설정하는 곳
- Appender 자체는 하나의 인터페이스를 의미하며, 하위에 여러 구현체가 존재함
    - ConsoleAppender: 콘솔에 로그 출력
    - FileAppender: 파일에 로그 저장
    - RollingFileAppender: 여러 개의 파일을 순회하면서 로그를 저장
    - SMTPAppender: 메일로 로그 전송
    - DBAppender: 데이터베이스에 로그를 저장

```xml
  <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
      <level>DEBUG</level> <!-- 어떤 레벨로 로그를 기록 -->
    </filter>
    <encoder>
      <pattern>%green([%d{yyyy-MM-dd HH:mm:ss.SSS}]) %magenta([%-5level]) %highlight([%thread]) %cyan(%logger{30}) %yellow(%msg%n)</pattern> <!-- 로그를 표현하는 패턴 정의 -->
    </encoder>
  </appender>
```
- level: 어떤 레벨의 로그를 기록할 것인가 (설정 로그 이상이 다 찍힘)
- encoder: 어떻게 출력할 것인가

### Root
```xml
<root level="INFO">
    <appender-ref ref="console">
</root>
```
- 여기서 설정된 Level 이상만 보여줌 (아무리 console이 Deug를 level로 설정해놨어도)
- 그리고 console 설정은 DEBUG 이상을 다 받고 console에는 INFO 이상만 찍음

### Logback 적용하기
- Logback은 출력할 메시지를 Appender에게 전달한 Logger 객체를 각 클래스에 정의해서 사용함
```java
private final Logger LOGGER = LoggerFactory.getLogger(GetController.class);
```
- LoggerFactory한테 GetController.class에서 사용할 Logger 객체를 하나 달라고 하는 느낌임
- 더 쉬운 방법
```java
@Slf4j
public class GetController {}
```
    - 단, log로 명시되어 있음 -> 다른 이름 사용 안됨

### Logger Test
```java
@GetMapping(value = "/logger-test/{var}")
public Integer loggerTest(
    @PathVariable("var") Integer var
) {
    log.info("var {}", var);
    if (true) {
        throw new RuntimeException("의도적인 에러");
    }
    return var;
}
```
    - var에 Integer 타입이 제대로 들어오면 INFO를 찍음
    - 안들오면 WARN을 찍음
    - 근데 런타임 에러를 강제로 던져서 ERROR 발생

### log.debug("변수: " + var); vs log.debug("변수: {}", var);
- 1번은 debug가 아니라면 사용은 안하지만 저 문자열 합치기 연산은 무조건 수행됨
- 2번은 debug일 경우를 확인을 먼저하고 문자열을 
- 그냥 log는 무조건 이렇게 출력하자!!! - 전문가들이 성능을 위해서 열심히 만들었다고하네!!
    
### logging 추가 공부
- MDC를 활용하여 로그가 뒤섞이는 문제 
    - 멀티 쓰레드 환경에서 동시에 여러 요청이 처리되기 때문에 동일한 요청에 대한 로그가 연속적으로 쌓이는 것이 아니라, 순서없이 쌓인다는 것
    - MDC(Mapped Diagnostic Context):
        - 현재 실행중인 쓰레드의 메타 정보를 넣고 관리하는 공간
        - Map으로 관리하고 있어 (Key, Value) 형태로 값을 저장할 수 있음

```java
package com.zrp.api.config.filter;

import java.io.IOException;
import java.util.UUID;

import org.slf4j.MDC;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component // 스프링 Bean으로 등록
@Order(Ordered.HIGHEST_PRECEDENCE) // 필터 중 가장 먼저 실행되도록 설정!!
public class CustomLoggingFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(
        HttpServletRequest request, 
        HttpServletResponse response, 
        FilterChain filterChain
    ) throws ServletException, IOException {
        // 1. 고유 ID 생성 (UUID의 앞 8자리만 사용해서 짧게 만듦)
        String traceId = UUID.randomUUID().toString().substring(0, 8);
        
        // 2. MDC에 저장 (이제부터 이 스레드에서 찍는 모든 로그는 이 ID를 공유함)
        MDC.put("traceId", traceId);

        response.setHeader("X-Trace-Id", traceId);

        try {
            // 3. 다음 로직 (컨트롤러 등) 실행
            filterChain.doFilter(request, response);
        } finally {
            // 4. 필수!!! 요청이 끝나면 MDC를 비워줘야 함 (스레드 풀 재사용 문제 방지)
            MDC.clear();
        }
            
    }

}
```
    - response.setHeader에 달아서 보낸며 사용자가 F12를 누르고 Network Tab에서 확인할 수 있음(Preserve Log check needed)

- logback-spring.xml 설정
```xml
<pattern>%green([%d{yyyy-MM-dd HH:mm:ss.SSS}]) [%X{traceId}] %magenta([%-5level]) %highlight([%thread]) %cyan(%logger{30}) %yellow(%msg%n)</pattern>
```
    - %X: 로깅이 발생한 쓰레드
    - 의 traceId라는 key 출력

### 로그 JSON으로 저장하기
- 의존성 설정
```java
// Logback JSON Encoder (실무 표준)
implementation 'net.logstash.logback:logstash-logback-encoder:7.4'
```

- logback-spring.xml
```yml
<property name="logdir" value="./logs"/>

<appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
        <level>ERROR</level>
    </filter>
    <append>true</append>
    <file>${logdir}/app-json.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>${logdir}/app-json.%d{yyyy-MM-dd}.log</fileNamePattern>
        <maxHistory>30</maxHistory>
    </rollingPolicy>

    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
        </encoder>
</appender>
```
- 한 파일에 붙이기 <append>true</append>
- 레벨은 ERROR만
encoding은 class="net.logstash.logback.encoder.LogstashEncoder" 얘가 알아서 JSON으로 바꿔줌
- 어디다가 저장?
    - value="./logs"/ - <file>${logdir}/app-json.log</file>
    - .위치는 logback-spring.yml이 있는 곳이 아니라 프로젝트 루트를 지짗
    - 로컬 용도는 상관없는데 실제 배포시 위치는 반드시 따로 고려해봐야함!!
