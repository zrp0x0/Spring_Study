# Ch06. 데이터베이스 연동

## ORM
- Object Relational Mapping의 줄임말로 객체 관계 매핑을 의미함
- 자바와 같은 객체지향 언어에서 의미하는 객체와 RDB의 테이블을 자동으로 매핑하는 방법
- 여기서 객체는 클래스를 의미함
- 클래스는 데이터베이스의 테이블과 매핑하기 위해 만들어진 것이 아니기 때문에 RDB 테이블과 어쩔 수 없는 불일치가 존재함
- ORM은 이 둘의 불일치와 제약사항을 해결하는 역할
- ORM을 사용하면 **쿼리**가 아닌 코드(메서드)로 데이터를 조작할 수 있음

### ORM의 장점
- ORM을 사용하면서 쿼리를 객체지향적으로 조작할 수 있음
    - 쿼리문 작성 양이 줄음
    - 코드의 가독성을 높일 수 있음

- 재사용 및 유지보수가 편리함
    - ORM울 통해 매핑된 객체는 모두 독립적으로 작성되어 있어 재상용이 용이함
    - 객체들은 각 클래스로 나뉘어 있어 유지보수가 수월함

- 데이터베이스에 대한 종속성이 줄어듦
    - ORM을 통해 자동 생성된 SQL문은 객체를 기반으로 데이터베이스 테이블을 관리하여 데이터베이스에 종속적이지 않음
    - 데이터베이스를 교체하는 상황에서도 비교적 적은 리스크를 부담함
    - 연결된 데이터베이스에 따라서 알아서 자동으로 생성해줌

### ORM의 단점
- ORM만으로 온전한 서비스를 구현하기에는 한계가 분명히 있음
    - 복잡한 서비스의 경우 직접 쿼리를 구현하지 않고 코드로 구현하기 어려움
    - 복잡한 쿼리를 정확한 설계 없이 ORM만으로 구성하면 속도 저하 등의 성능 문제가 발생할 수 있음

- 애플리케이션의 객체 관점과 데이터베이스의 관계 관점의 불일치가 발생함
    - 세분성: ORM의 자동 설계 방법에 따라 데이터베이스에 있는 테이블의 수와 애플리케이션의 엔티티 클래스의 수가 다른 경우가 생김 (클래스가 테이블 수보다 많아질 수 있음)
    - 상속성: RDBMS에는 상속이라는 개념이 없음
    - 식별성: RDBMS는 기본키로 동일성을 정의함 / 하지만 자바는 두 객체의 값이 같아도 다르다고 판달할 수 있음 (식별과 동일성의 문제)
    - 연관성: 객체지향 언어는 객체를 참조함으로써 연관성을 나타내지만 RDBMS에서는 외래키를 삽입함으로 연관성을 표현함
    - 탐색: 자바는 객체 참조 같은 연결 수단을 활용함
        - member.getOrganization().getAddress()
        - 반면 RDBMS는 쿼리를 최소화하고 조인을 통해 여러 테이블을 로드하고 값을 추출하는 접근 방식을 채택

--- 

## JPA
- Java Persistence API는 자바 진영의 ORM 기술 표준으로 채택된 인터페이스의 모음
- ORM이 큰 개념이라면 JPA는 더 구체화된 스펙을 포함함
- JPA의 역할이 ORM이라고 보면 무난함
- JPA의 메커니즘을 보면 내부적으로 JDBC를 사용함
    - 개발자가 직접 JDBC를 구현하면 SQL에 의존하게 되는 문제 등이 있어 개발의 효율성이 떨어지는데
    - JPA는 적절한 SQL을 자동으로 생성하고 DB를 조작해줌

- JPA의 구현체
    - 이클립스 링크
    - 데이터 뉴클리어스
    - 하이버네이트(Hibernate)

### Hibernate
- JPA가 정의하는 인터페이스를 구현하고 있는 JPA 구현체
- 하이버네이트의 기능을 더욱 편하게 사용하도록 모듈화한 Spring Data JPA를 사용
- 쉽게 말하면 하이버네이트의 Entity Manager를 직접 다루지 않고 리포지터리를 정의해 사용함으로써 스프링이 적합한 쿼리를 동적으로 생성하는 방식으로 데이터베이스를 조작함
- 구조도
    - 스프링 부트 어플리케이션 <-> Hibernate [Spring Data JPA] <-> DB

### 영속성 컨텍스트
- Persistence Context는 애플리케이션과 데이터베이스 사이에서 엔티티와 레코드의 괴리를 해소하는 기능과 객체를 보관하는 기능을 수행함
- 엔티티 객체가 영속성 컨텍스트에 들어오면 JPA는 엔티티 객체의 매핑 정보를 데이터베이스에 반영하는 작업을 수행함
- 엔티티 객체가 영속성 컨텍스트에 들어와 JPA의 관리 대상이 되는 시점부터 해당 객체를 영속 객체라고 부름
    - 세션 단위의 생명주기를 가짐
    - 디비 접근을 위해서 세션이 생성되면 영속성 컨텍스트가 만들어지고, 세션이 종료되면 영속성 컨텍스트도 없어짐
    - 쉽게 말하면 DB에 저장하기 전에 데이터를 잠시 보관하고 관리하는, 아주 똑똑한 임시 메모리 공간

### 엔티티 매니저
- SimpleJpaRepository가 엔티티 매니저를 사용함
- 스프링 부트는 자동 설정 기능이 있지만
- 하이버네이트에서는 persistence.ml이라는 설정 파일을 구성하고 사용해야하는 객체

### 엔티티 생명주기
- 비영속(New)
    - 영속성 컨텍스트에 추가되지 않은 엔티티 객체의 상태를 의미함

- 영속(Managed)
    - 영속성 컨텍스트에 의해 엔티티 객체가 관리되는 상태

- 준영속(Detached)
    - 영속성 컨텍스트에 의해 관리되던 엔티티 객체가 컨텍스트와 분리된 상태

- 삭제(Removed)
    - 데이터베이스에서 레코드를 삭제하기 위해 영속성 컨텍스트에 삭제 요청을 한 상태

### 그래서 영속이 뭔데
- JVM 외부에 객체를 영원히 관리하고 싶음
- JVM을 벗어나면 자바 객체도 사라짐(엔티티)
- JPA는 이를 JVM 밖에서도 유지하고 싶었음
- 밖이라는 데이터베이스, 텍스트 파일이 될 수도 있음

### 데이터베이스 연동
```yml
# application.yml
spring:
  application:
    name: jpa

  datasource:
    # 1. 데이터베이스 접속 정보
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 'my_db_name' 부분에 본인의 데이터베이스 이름(스키마명)을 넣으세요.
    # ?serverTimezone=Asia/Seoul : 한국 시간 설정 (필수 권장)
    # &characterEncoding=UTF-8 : 한글 깨짐 방지
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=Asia/Seoul&characterEncoding=UTF-8
    username: root # DB 아이디
    password: 1234 # DB 비밀번호

  jpa:
    # 2. 하이버네이트 설정 (JPA 구현체)
    hibernate:
      # [매우 중요] ddl-auto 옵션
      # create: 시작할 때 기존 테이블 삭제 후 다시 생성 (데이터 다 날아감, 주의!)
      # create-drop: create와 같으나 종료 시점에 테이블 삭제 (테스트용)
      # update: 변경된 스키마만 반영 (데이터 유지, 개발 시 추천)
      # validate: 엔티티와 테이블이 정상 매핑되었는지만 확인 (운영 서버용)
      # none: 아무것도 안 함
      ddl-auto: create
    
    # 3. SQL 로그 설정
    # 실행되는 SQL을 콘솔에 보여줄지 여부
    show-sql: true
    
    properties:
      hibernate:
        # SQL을 예쁘게 정렬해서 보여줌 (가독성 UP)
        format_sql: true
        
        # (선택) SQL 파라미터 값을 '?' 대신 실제 값으로 보여줌 (외부 라이브러리 필요할 수 있음)
        # use_sql_comments: true 
        
        # MySQL 버전에 맞는 방언(Dialect) 설정
        # 명시하지 않아도 자동 감지되지만, 오류 방지를 위해 적어주는 것이 좋음
        dialect: org.hibernate.dialect.MySQL8Dialect
```
    - 주의: 운영환경에서는 create / create-drop / update 기능은 사용하지 않음
    - 대체로 validate나 none을 적용함
    - 개발환경에서는 create / update
    - 추가로 update를 적용해도 한 번 생성된 컬럼의 제약 조건은 변하지 않음 -> DB 밀어버리고 다시해야함

### 엔티티 설계
- Spring Data JPA를 사용하면 데이터베이스에 테이블을 생성하기 위해 직접 쿼리를 작성할 필요가 없음
- 이 기능을 가능하게 하는 것이 @Entity
- JPA에서 엔티티는 데이터베이스 테이블에 대응하는 클래스
```java
package com.zrp.jpa.data.entity;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name = "product")
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long number;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private Integer price;

    @Column(nullable = false)
    private Integer stock;

    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;
    // .. Getter Setter 메서드
}
```

### 엔티티 관련 기본 어노테이션
- @Entity
    - 해당 클래스가 엔티티임을 명시하기 위해서 사용
    - 클래스 자체는 테이블과 일대일로 매칭되며, 해당 클래스의 인스턴스는 매핑되는 테이블에서 하나의 레코드를 의미함

- @Table
    - 엔티티 클래스는 테이블과 매핑되므로 특별한 경우가 아니면 @Table 어노테이션이 필요하지 않음
    - 클래스 이름과 테이블의 이름을 다르게 지정해야하는 경우 사용함
    - 대체로 자바의 명명법과 데이터베이스가 사용하는 명명법이 다르기 때문에 자주 사용함

- @Id
    - 엔티티 클래스의 필드는 테이블의 컬럼과 매핑됨
    - @Id로 선언된 필드는 테이블의 기본키 역할로 사용됨
    - 모든 엔티티에는 하나가 무조건 있어야함
        - 하나는 있어야하는데 그 이상의 경우 unique로 처리하는 경우가 많음

- @GeneratedValue
    - @Id와 보통 함께 사용함
    - 해당 필드의 값을 어떤 방식으로 자동으로 생성할지 결정할 때 사용함
        - 1. 그냥 초기화(기본값)
        - 2. AUTO: @GeneratedValue의 기본 설정값: 기본값을 사용하는 데이터베이스에 맞게 자동 생성
        - 3. IDENTITY: 기본값 생성을 데이터베이스에 위임하는 방식
            - AUTO_INCREMENT를 사용해 기본값을 생성함
        - 4. SEQUENCE
            - @SequenceGenerator 어노테이션으로 식별자 생성기를 설정하고 이를 통해 값을 자동 주입받습니다.
        - 5. TABLE
            - 어떤 DBMS를 사용하더라도 동일하게 동작하기를 원할 경우 사용함
            - 식별자로 사용할 숫자의 보관 테이블을 별도로 생성해서 엔티티를 생성하 때마다 값을 갱신하며 사용함
            - @TableGenerator 어노테이션으로 테이블 정보를 설정함

- @Column
    - 엔티티 클래스의 필드는 자동으로 테이블 컬럼으로 매핑됨
    - 별다른 설정을 하지 않을 예정이라면 명시하지 않아도 됨
    - 필드에 몇가지 설정을 더할 때 사용
        - name: 컬럼명 설정(기본은 필드명으로 지정됨)
        - unique: 해당 컬럼을 유니크로 설정
        - nullable: 컬럼값에 null이 있으면 안됨
        - insertable: 저장할 때 이 값을 포함할지 여부 (false로 설정하면 저장할 때 DB에 저장안됨 - 읽기 전용)
        - updatable: 수정할 때 이 값을 포함할지 여부(생성 시간)
        - columnDefinition: (DDL): 데이터베이스 컬럼 정보를 직접 SQL로 
            - @Column(columnDefinition = "varchar(100) default 'EMPTY'")
        - length: 데이터의 최대 길이 설정
        - precision: (DDL): 전체 자릿수 (소수점 포함)
        - scale: (DDL): 소수점 이하 자릿수

- @Transient
    - 엔티티 클래스에 선언되어있는 필드지만 디비에는 필요 없을 경우 사용함

### 리포지토리 인터페이스 설계
- 